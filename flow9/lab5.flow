import runtime;
import string;
import lingo/pegcode/driver;

Expr ::= IntConst, Add, Mul;
IntConst(val: int);
Add(lhs: Expr, rhs: Expr);
Mul(lhs: Expr, rhs: Expr);


RPN ::= IntConstRPN, AddRPN, MulRPN;
IntConstRPN(val: int);
AddRPN();
MulRPN();
/*
arithGramarOp: ref Maybe<[PegOp]> = ref None();

initGrammar(){
    onlyOnce(arithGramarOp, \ -> {
        compilePegGrammar("#include RPN.lingo");
    });
}

s2ar(s: string) -> Expr {
    parsic(initGrammar(), s, defaultPegActions)
}
*/

s2ar(s: string) -> Expr {
    gram = "#include ex.lingo";
    parsic(compilePegGrammar(gram), s, defaultPegActions)
}

ar2i(e : Expr) -> int {
    switch(e: Expr) {
        Add(a, b): ar2i(a) + ar2i(b)
        Mul(a, b): ar2i(a) * ar2i(b)
        IntConst(a): a
    }
}

ar2s(e : Expr, str : string) -> string {
    switch(e: Expr) {
        Add(a, b): str + ar2s(a, str) + "+" + ar2s(b, str)
        Mul(a, b): str + ar2s(a, str) + "*" + ar2s(b, str)
        IntConst(a): str + i2s(a)
    }
}

ar2rpn(e: Expr) -> [RPN] {
	switch(e: Expr) {
		Add(a, b): concat(concat([AddRPN()], ar2rpn(a)), ar2rpn(b))
		Mul(a, b): concat(concat([MulRPN()], ar2rpn(a)), ar2rpn(b))
		IntConst(a): [IntConstRPN(a)]
	}
}

ar2rpnsize(e: Expr) -> int {
        switch(e: Expr) {
                Add(a, b): 1 + ar2rpnsize(a) +  ar2rpnsize(b)
                Mul(a, b): 1 + ar2rpnsize(a) +  ar2rpnsize(b)
                IntConst(a): 1
        }
}

rpn2ar(e: [RPN], i: int) -> Maybe<Expr> {
	if(i >= length(e)) {
		None()
	} else {
		switch(e[i]) {
			AddRPN(): {
				left = rpn2ar(e, i + 1);
				len = maybeBind(left, fn2some(\ v -> ar2rpnsize(v) + 1));
				right = maybeBind(len, \ v -> rpn2ar(e, i + v));
				maybeBind(right, \ r -> maybeBind(left, \ l -> Some(Add(l, r))))
			}
			MulRPN(): {
				left = rpn2ar(e, i + 1);
				len = maybeBind(left, fn2some(\ v -> ar2rpnsize(v) + 1));
				right = maybeBind(len, \ v -> rpn2ar(e, i + v));
				maybeBind(right, \ r -> maybeBind(left, \ l -> Some(Mul(l, r))))
			}
			IntConstRPN(a): Some(IntConst(a))
		}
	}
}

rpn2i(e: [RPN]) -> Maybe<int> {
	ar = rpn2ar(e, 0);
	switch(ar: Maybe) {
		None(): None()
		Some(v): Some(ar2i(v))
	}
}

main() {
    str = "((5  * 1) + (3 * 3 ))";
    e = s2ar(str);
    r = ar2rpn(e);
    iter(r, \v -> {
			switch(v) {
				AddRPN() : println("+");
				MulRPN() : println("*");
				IntConstRPN(a) : println(i2s(a));
			}
	});
/*
	switch(rpn2i(r) : Maybe) {
		None() : println("Wrong expression!");
		Some(v) : println(i2s(v));
	}

	z : [RPN] = [AddRPN(), MulRPN(), AddRPN()];
	switch(rpn2i(z) : Maybe) {
		None() : println("Wrong expression!");
		Some(v) : println(i2s(v));
	}*/
}