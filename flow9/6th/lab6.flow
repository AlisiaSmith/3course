ExprRNP ::= IntConstRNP, MulRNP, AddRNP;
IntConstRNP: (value: int);
MulRNP: (); //1*2*3*4
AddRNP: ();

Expr ::= IntConst, Mul, Add;
IntConst: (value: int);
Mul: (l: Expr, r: Expr); //1*2*3*4
Add: (l: Expr, r: Expr); 


arithGramarOp: ref Maybe<[PegOp]> = ref None();

initGrammar(){
    onlyOnce(arithGramarOp, \ -> {
        compilePegGrammar("#include RPN.lingo");
    });
}

s2ar(s: string) -> Expr {
    gram = "#include ex.lingo";
    parsic(compilePegGrammar(gram), s, defaultPegActions)
}

pop(stack: ref [?])->?{
    element=^stack[length(^stack)-1];
    stack := subrange(^stack, 0, length(^stack)-1);
    element;
}

Calc(e: [ExprRNP])->int{
    r = fold(e, ref[], \stack, exp ->{
        switch(exp){
            IntConstRNP(c): refArrayPush(stack, c);
            MulRNP(): refArrayPush(stack, pop(stack)*pop(stack));
            AddRNP(): refArrayPush(stack), pop(stack)+pop(stack);
        };
        stack;
    })
    pop(r);
};

Parse(source:string)->[ExprRNP]{
    parsic(initGrammar(), source,defaultPegActions);
}

ar2rpn(e: Expr)->[ExprRNP]{  //My
    fold(e, ref[], \stack, exp ->{ //what is fold?
        switch (exp) {
        IntConst(c): refArrayPush(stack, IntConstRNP(c));
        Mul(l,r):
        {
            ar2rpn(l);
            ar2rpn(r);
            refArrayPush(stack, MulRNP())  
        }
        Add(l,r):     
       {
            ar2rpn(l);
            ar2rpn(r);
            refArrayPush(stack, AddRNP())  
        }
    }
}


rpn2ar([e: ExprRNP])->Expr{ //My
    fold(e, [], \stack, exp->{
        switch (exp) {
            IntConst(c): IntConst(pop(stack));
            MulRNP():  Mul(rpn2ar(pop(stack)), rpn2ar(pop(stack)));
            AddRNP():  Add(rpn2ar(pop(stack)), rpn2ar(pop(stack)));   
        }
    })
}

Calc(e:Expr)->int{
    switch (e : Expr) {
    IntConst(c):c;
    Mul(l,r):Calc(l)*Calc(r);
    Add(l,r):Calc(l)+Calc(r);
    }
}

Print(e:Expr)->string{
    switch (e : Expr) {
        IntConst(c):i2s(c);
        Mul(l,r):"("+Print(l)+"*"+Print(r)+")";
        Add(l,r):"("+Print(l)+"+"+Print(r)+")";
    }
}

//str2rpn(String)->[ExprRNP]{}
rpnCalc(e: [ExprRNP])->int{
    fold(e, [], \stack, exp->{
        switch (exp) {
            IntConst(c): refArrayPush(stack, c);
            Mul(): refArrayPush(stack, pop(stack)*pop(stack));
            Add(): refArrayPush(stack), pop(stack)+pop(stack);
        }
        stack;
    })
    pop(r);
}


main(){
    exp = "((5 * 1) + (3 * 3 ))";
    print(s2ar(exp));
   /* rpn = "1 2 3 4 + * +";
    result = Parse(rpn);
    println(result);
    printn(Print(result));
    println(Calc(result));
    quit(0);*/
}