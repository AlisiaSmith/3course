import runtime;
import string;
import lingo/pegcode/driver;


ExprRNP ::= IntConstRNP, MulRNP, AddRNP;
IntConstRNP: (value: int);
MulRNP: (); //1*2*3*4
AddRNP: ();

Expr ::= IntConst, Mul, Add;
IntConst: (value: int);
Mul: (l: Expr, r: Expr); //1*2*3*4
Add: (l: Expr, r: Expr); 


/*arithGramarOp: ref Maybe<[PegOp]> = ref None();

initGrammar(){
    onlyOnce(arithGramarOp, \ -> {
        compilePegGrammar("#include RNP.lingo");
    });
}

s2rnp(source:string)->[RNP]{
    parsic(initGrammar(), source,defaultPegActions);
}

s2ar(s: string) -> Expr {
    gram = "#include ex.lingo";
    parsic(compilePegGrammar(gram), s, defaultPegActions)
}*/

pop(stack: ref [?])->?{
    element=^stack[length(^stack)-1];
    stack := subrange(^stack, 0, length(^stack)-1);
    element;
}

CalcRNP(e: [ExprRNP])->int{
    r = fold(e, ref[], \stack, exp ->{
        switch(exp){
            IntConstRNP(c): refArrayPush(stack, c);
            MulRNP(): refArrayPush(stack, pop(stack)*pop(stack));
            AddRNP(): refArrayPush(stack, pop(stack)+pop(stack));
        };
        stack;
    })
    pop(r);
};


/*
ar2rpn(e: Expr)->[ExprRNP]{  //My
    fold(e, ref[], \stack, exp ->{ //what is fold?
        switch (exp) {
        IntConst(c): refArrayPush(stack, IntConstRNP(c));
        Mul(l,r):
        {
            refArrayPush(stack, MulRNP())  
            ar2rpn(l);
            ar2rpn(r);
        }
        Add(l,r):     
       {
            refArrayPush(stack, AddRNP())  
            ar2rpn(l);
            ar2rpn(r);
        }
    }
}
}*/


/*rpn2ar(e: [ExprRNP])-> Expr { //My
    fold(e, ref[], \stack, exp->{
        switch (exp) {
            IntConst(c): IntConst(pop(stack));
            MulRNP():  Mul(rpn2ar(pop(stack)), rpn2ar(pop(stack)));
            AddRNP():  Add(rpn2ar(pop(stack)), rpn2ar(pop(stack)));   
        }
    })
}*/

Calc(e : Expr)->int{
    switch (e : Expr) {
    IntConst(c):c;
    Mul(l,r):Calc(l)*Calc(r);
    Add(l,r):Calc(l)+Calc(r);
    }
}   


ar2s(e:Expr)->string{
    switch (e : Expr) {
        IntConst(c):i2s(c);
        Mul(l,r):"("+ar2s(l)+"*"+ar2s(r)+")";
        Add(l,r):"("+ar2s(l)+"+"+ar2s(r)+")";
    }

}

rpn2s(e: Maybe<[ExprRNP]>) -> string {
    
		switch(e[1]) {
			AddRNP() :  "+ " + rnp2s(e[2]);
			MulRNP() :  "* " + rnp2s(e[2]);
			IntConstRNP(a) : i2s(a) + " " + rnp2s(e[2]);
            None(): "";
		}
}

/*CalcRNP(e: [ExprRNP])->int{
    fold(e, [], \stack, exp->{
        switch (exp) {
            IntConstRNP(c): refArrayPush(stack, c);
            MulRNP(): refArrayPush(stack, pop(stack)*pop(stack));
            AddRNP(): refArrayPush(stack, pop(stack)+pop(stack));
        }
        stack;
    })
    pop(r);
}*/


main(){

    exp = [IntConstRNP(3),IntConstRNP(3), MulRNP()];
    println(CalcRNP(exp));
    //exp = "((5 * 1) + (3 * 3 ))";
    //println(s2ar(exp));
   // println(rnp2s(ar2rnp(s2ar(exp))));
   /* rpn = "1 2 3 4 + * +";
    result = Parse(rpn);
    println(result);
    printn(Print(result));
    println(Calc(result));
    quit(0);*/
    quit(0);
}